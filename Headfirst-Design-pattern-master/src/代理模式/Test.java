package 代理模式;

/**
 * 控制对象访问---代理模式
 * 场景：现在，我想要实现跨服务器通信。把系统扩展到多个服务器之间相互调用的程度。
 *
 * 远程代理的角色：
 *  远程代理就好比“远程对象的本地代表”。
 *  何谓“远程对象”？这是一种对象，活在不同的Java虚拟机堆中（在不同的地址空间运行的远程对象）。
 *  何谓“本地代表”？就是一种可以由本地方法调用的对象，器行为会转发到远程对象中。
 *
 *  什么意思？ 在我本机的JVM中，无法取得另个一堆的对象的引用。或者说，你不能这么写：
 *      Duck d = <另一个堆的对象></>
 *
 *
 *  RMI：可以让我们找到远程JVM内的对象，并允许我们调用它们。下面进入教学
 *  --远程方法
 *      假如我们需要设计一个系统，能够调用本地对象，然后每个请求都转发到远程对象上。如何设计？
 *      我们需要一些辅助对象，帮我们进行沟通，这些辅助对象使客户像调用本地对象一样地调用远程对象。
 *
 *      两个要素--1.服务端辅助对象  2.客户端辅助对象
 *      通过Socket连接（！！！！），将调用的信息解包，然后调用真正服务对象上的真正方法。
 *
 *  --Java RMI概述
 *      RMI将客户辅助对象称为 stub(桩)，服务辅助对象称为skeleton(框架)
 *  --那么，如何制作远程服务（将一个对象变成可以被远程客户调用的  远程对象）
 *      1.制作远程接口（供客户端调用的）
 *      2.制作远程的实现类（实际工作的类，也就是客户端真正想要获取的类）
 *      3.利用rmic产生的stub和skeleton（辅助类。不需要自己创建，JDK自带！！）
 *      4.启动RMI registry    ---像一个电话簿，可以从中查到代理的位置
 *      5.开始远程服务---必须让服务对象开始运行，必须将服务实现类实例化，注册到RMI registry，就可以供其它服务器调用了。
 *
 *
 *
 * 在二_简单实现中，我们演示了远程代理。下面正是介绍代理模式
 * 代理模式：代理模式为另一个对象提供一个替身或占位符以控制对这个对象的访问。
 *
 * 与装饰者模式的区别
 *  意图不同，装饰者是为对象添加内容，代理是拦截对象行为加以修改和控制。
 *  工作不同：装饰者改变了对象的内容，代理没有。
 * 如何让客户使用代理？
 *  提供一个工厂，实例化并返回代理，而不开放真实对象的构造。
 *
 * 除了这里演示的三类--
 * 远程代理（远程调用中使用--远程对象的本地“代表”）
 * 虚拟代理（对象不存在或尚未创建时的“代表”（假装对象存在））
 * 保护代理（拦截并控制对象某些行为（流程、访问权限等））
 *
 * 还有许多变种：
 * 防火墙代理（控制网络资源的访问，保护主体免受“坏客户”的侵害）
 * 缓存代理（为开销大的运算结果提供暂时储存（避免反复执行某些大运算，相当于开辟一块“计算结果暂存区”））
 * 同步代理（多线程情况下提供安全访问）
 *
 */
public class Test {
}
